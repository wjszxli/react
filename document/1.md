### React 15 的 Stack Reconciler 存在的问题

JS 的线程和渲染线程必须是互斥的，如果 JS 线程执行的时间过长，留给渲染线程的时间就不足了，需要长时间的进行等待，造成卡顿，如果卡顿的时候在页面上点击，更会导致事件线程在也队列中
排队等待 js 执行完，触发的事件难以被响应，这是 Stack Reconciler 困局所在

Stack Reconciler 是一个同步的递归过程，深度优先遍历一棵树，整个过程是同步的，不可以被打断，而且递归还有限制，限制在 10000 次，如果深度递归的时间过长， JS 线程长时间占用主线程，导致渲染卡顿/卡死、交互长时间无响应。

### Fiber 如何解决长时间占用的问题
#### 定义
纤程，比线程还更细，对渲染过程实现更加精细的控制
#### 多重角度看
- 架构：对调和过程的重写
- 编码角度：内部定义的一种数据结构，Fiber 树结构的节点单位，React 16 结构下的虚拟 DOM，
- 工作流来看：Fiber 节点保存了组件需要更新的状态和副作用，一个 Fiber 同时对应一个工作单元
#### 架构应用目的
实现“增量渲染”，把一个渲染任务分解为多个渲染任务，多个渲染任务分散到多个帧里面，最终目的实现任务的可中断、可恢复、并给不同的任务赋予不同的优先级，最终达到更加顺滑的用户体验

#### Fiber 架构核心：可中断，可恢复与优先级
![](https://s0.lgstatic.com/i/image/M00/6E/D8/CgqCHl-zlfaALmyYAABbITniefc225.png)
增加了一层 Scheduler，作用是调度更新的优先级，因为有了 Scheduler，工作流变成了如下：
1. 每个更新任务赋予一个优先级，当更新任务抵达调度器时，高优先级的更新任务会更快的被调度进 Reconciler 层，当前处于 Reconciler 的任务会被中断，调度器将优先级更高的任务推入 Reconciler 层（这就是可中断），
更高优先级的任务渲染完成之后，原来被中断的任务重新推入 Reconciler 层，继续渲染，这就是可恢复。

#### 新的 Fiber 架构对 React 生命周期的影响
新的架构对 React 生命周期影响主要在 render 阶段，通过增加 Scheduler 层和改写 Reconciler 层来实现的，在 render 阶段，一个庞大的更新任务被分解长一个个的工作单元，工作单元有着不同的优先级，React 可以根据优先级的高低来实现工作单元的打断和恢复，render 阶段的操作对于用来来说是不可见的，所以打断和重启对用户来说也是 0 感知，但工作单元的重启会对部分生命周期重复执行。如：
- componentWillMount
- componentWillUpdate
- shouldComponentUpdate
- componentWillReceiveProps

